/*  Author: Afag Rizayeva
    Date: 01-17-2022
    Purpose: Calculate second-order texture metrics from Corona imagery
    Inputs: 2 Corona image layers manually imported in GEE

    Instructions:
    Delete the geometries that I used.
    Adjust lines 14 and 17 according to the geometry we want to calculate by clipping them with the geometry cordinates (uncomment lines 15 and 18).
    Press Ctrl+F twice. In Replace from cell paste: "1024-2104" and in Replace to cell paste your Corona images' code.
    Do it once again without the hyphen.
    Run the code first and create the appropriate geometries. (because the whole image is usually too large, but depends on your study. You may not need this step).
    When exporting the layers make sure to add the geometry number at the end of the file and task names in the pop-up window
*/

// var image2 = ee.Image('users/rizayeva/corona_2_5m/DS1011-1040DA_2_5m_JPEG_1band_EPSG32638');
// var image3 = ee.Image('users/rizayeva/corona_2_5m/DS1011-1040DF_2_5m_JPEG_1band_EPSG32638');
// var image2 = ee.Image('users/rizayeva/corona_2_5m/DS1025-1072_DA_2_5m_JPEG_1band_EPSG32638');
// var image3 = ee.Image('users/rizayeva/corona_2_5m/DS1025-1072_DA_2_5m_JPEG_1band_EPSG32638');
// var image2 = ee.Image('users/rizayeva/corona_2_5m/DS1023-2087_DA_2_5m_JPEG_1band_EPSG32638');
// var image3 = ee.Image('users/rizayeva/corona_2_5m/DS1023-2087_DF_2_5m_JPEG_1band_EPSG32638');
var image2 = ee.Image('users/rizayeva/corona_2_5m/DS1024-2104DA_1band_LZWcomp_EPSG32638_JPEG');
var image3 = ee.Image('users/rizayeva/corona_2_5m/DS1024-2104DF_1band_JPEGcomp_EPSG32638_JPEG');
var image2 = image2.select(['b1'],['da']);
var image3 = image3.select(['b1'],['df']);

var img = ee.Image.cat([image2, image3]);
print(img);
print('Band names: ', img.bandNames()); // ee.List of band names

var img = ee.Image(img).divide(255);
Map.addLayer(img, {bands: ["df", "df", "da"], gamma: 0.8}, 'DS_DADF');
Map.centerObject(img.geometry(), 7);
Map.addLayer(table4, {}, 'training points');

/////////////Segmentation
var seeds = ee.Algorithms.Image.Segmentation.seedGrid(40);
// Run SNIC on the regular square grid.
var snic = ee.Algorithms.Image.Segmentation.SNIC({
  image: img, 
  size: 32,
  compactness: 0.1,
  connectivity: 4,
  neighborhoodSize:256,
  seeds: seeds
}).select(['da_mean', 'df_mean', 'clusters'], ['da', 'df', 'clusters']).reproject({crs: 'EPSG:4326', scale: 18});

var snicbandNames = snic.bandNames();
print('Snic band names: ', snicbandNames); // ee.List of band names
var clusters = snic.select('clusters');
//Map.addLayer(clusters.randomVisualizer(), {}, 'clusters', false)
Map.addLayer(snic, {bands: ['da', 'df'/*, 'b1_2', 'b1_3'*/], min:0, max:1, gamma: 0.8}, 'means', false);

/////////////Vectorize the objects
var tiles = image2.addBands(image3).reduceToVectors({
  reducer: ee.Reducer.mean(), 
  geometry: image2.addBands(image3).geometry(), 
  geometryType: 'bb',
  scale: 12000, 
  eightConnected: false,
  labelProperty: 'object',
});
Map.addLayer(tiles, {}, 'tiles', false);

var tiles = ee.FeatureCollection(tiles);
var buffer = function(feature) {
return feature.buffer(1000);};
//Buffer creation
var tilesbuffer = tiles.map(buffer);
var tilesbuffer = ee.FeatureCollection(tilesbuffer);
print('tilesbuffer', tilesbuffer);
var tilesbuffer_list =tilesbuffer.toList(tilesbuffer.size());
print('tilesbuffer_list', tilesbuffer_list);
Map.addLayer(tilesbuffer, {}, 'tilesbuffer');
var size = tilesbuffer_list.size().getInfo();
// ee.Feature(collection.toList(3).get(1))

var classes = ee.FeatureCollection(table4.select('FID_test_l'));
print('classes', classes.first());

// Define a spatial filter as geometries that intersect.
var spatialFilter = ee.Filter.intersects({
  leftField: '.geo',
  rightField: '.geo',
  maxError: 10
});

//do merging first and then select all objects that are under each point // Define a save all join.
var saveAllJoin = ee.Join.saveAll({
  matchesKey: 'FID_test_l',
});

var trainobjs = [];
var i;
for (i = 0; i < size; i++) {
var trainingobjects = saveAllJoin.apply(clusters.reduceToVectors({
  reducer: ee.Reducer.countEvery(), 
  geometry: ee.Feature(tilesbuffer_list.get(i)).geometry(),
  scale: 2.5,
  eightConnected: false,
  maxPixels: 1e15
}), classes, spatialFilter);
trainobjs[i]=trainingobjects;   
}

print('trainobjs', trainobjs);
var trainobjsfeat = ee.FeatureCollection(trainobjs).flatten();
Map.addLayer(trainobjsfeat, {}, 'trainobjsfeat', false);
print('trainobjsfeat', trainobjsfeat);

// Export the FeatureCollection.
Export.table.toDrive({
  collection: trainobjsfeat,//class,
  description: 'trainobjsfeatclass_DS10',
  fileFormat: 'GeoJSON'//'shp'
});


// var classes = ee.FeatureCollection(table3.select('FID_test_l'));
// print('classes', classes.first());

// // Define a spatial filter as geometries that intersect.
// var spatialFilter = ee.Filter.intersects({
//   leftField: '.geo',
//   rightField: '.geo',
//   maxError: 10
// });

// //do merging first and then select all objects that are under each point // Define a save all join.
// var saveAllJoin = ee.Join.saveAll({
//   matchesKey: 'FID_test_l',
// });

// var trainobjs = [];
// var i;
// for (i = 0; i < size; i++) {
// var trainingobjects = saveAllJoin.apply(clusters.reduceToVectors({
//   reducer: ee.Reducer.countEvery(), 
//   geometry: ee.Feature(tilesbuffer_list.get(i)).geometry(),
//   scale: 2.5,
//   eightConnected: false,
//   maxPixels: 1e15
// }), classes, spatialFilter);
// trainobjs[i]=trainingobjects;   
// }

// print('trainobjs', trainobjs);
// var trainobjsfeat = ee.FeatureCollection(trainobjs).flatten();
// Map.addLayer(trainobjsfeat, {}, 'trainobjsfeat', false);
// print('trainobjsfeat', trainobjsfeat);

// // Export the FeatureCollection.
// Export.table.toDrive({
//   collection: trainobjsfeat,//class,
//   description: 'trainobjsfeatclass_DS10',
//   fileFormat: 'GeoJSON'//'shp'
// });
