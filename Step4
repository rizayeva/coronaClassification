/*  Author: Afag Rizayeva
    Date: 01-17-2022
    Purpose: Calculate second-order texture metrics from Corona imagery
    Inputs: 2 Corona image layers manually imported in GEE
            texture layers
            training and testing data
            Corona geometry
    
    Instructions:
    Adjust locations for input files:
              texture layers - lines 20-25;
              training and testing data - lines 41-60;
              corona layers;
              geometry of Corona (variable called "clip") - line 76.
    Run the code
    
    Export the accuracies as csv files and the final classification map
*/

var entropy_DA = ee.Image('users/rizayeva/GLCM/entropy_DA').toFloat();
var entropy_DF = ee.Image('users/rizayeva/GLCM/entropy_DF').toFloat();
var homogeneity_DA = ee.Image('users/rizayeva/GLCM/homogeneity_DA').toFloat();
var homogeneity_DF = ee.Image('users/rizayeva/GLCM/homogeneity_DF').toFloat();
var angularSecondMoment_DA = ee.Image('users/rizayeva/GLCM/angularSecondMoment_DA').toFloat();
var angularSecondMoment_DF = ee.Image('users/rizayeva/GLCM/angularSecondMoment_DF').toFloat();

var imageVisParam = {bands: ['ds10111040da_ent'], min: 0.6920778192348177, max: 4.140394044612628,  gamma: [1]};
Map.addLayer(entropy_DA, imageVisParam, 'entropy_DA', false);
var imageVisParam = {bands: ['ds10111040df_ent'], min: 3.0209101473712536, max: 3.9960161288948637,  gamma: [1]};
Map.addLayer(entropy_DF, imageVisParam, 'entropy_DF', false);
var imageVisParam = {bands: ['ds10111040da_idm'], min: 0.10173501666498017, max: 0.49671797626021486,  gamma: [1]};
Map.addLayer(homogeneity_DA, imageVisParam, 'homogeneity_DA', false);
var imageVisParam = {bands: ['ds10111040df_idm'], min: 0.10173501666498017, max: 0.49671797626021486,  gamma: [1]};
Map.addLayer(homogeneity_DF, imageVisParam, 'homogeneity_DF', false);
var imageVisParam = {bands: ['ds10111040da_asm'], min: 0.015129123106179802, max: 0.02445575399273777,  gamma: [1]};
Map.addLayer(angularSecondMoment_DA, imageVisParam, 'angularSecondMoment_DA', false);
var imageVisParam = {bands: ['ds10111040df_asm'], min: 0.015071922070983398, max: 0.06105865647962591,  gamma: [1]};
Map.addLayer(angularSecondMoment_DF, imageVisParam, 'angularSecondMoment_DF', false);

var palette = ['075b0e',  '075b0e', '075b0e', 'ebebeb', '9de64e', 'e2d544', 'ff0000', '3f553c', '0033ff', 'ffffff', '88cdf6'];
var image2 = ee.Image('users/rizayeva/corona_2_5m/DS1011-1040DA_2_5m_JPEG_1band_EPSG32638').rename(['ds10111040da']);
var image3 = ee.Image('users/rizayeva/corona_2_5m/DS1011-1040DF_2_5m_JPEG_1band_EPSG32638').rename(['ds10111040df']);
Map.addLayer(image2, {min: 0, max: 200}, 'imageDA', false);
Map.addLayer(image3, {min: 0, max: 200}, 'imageDF', false);

var clip = ee.FeatureCollection('users/rizayeva/DS1011-1040');
var dataset = ee.Image('USGS/SRTMGL1_003');
var elevation = dataset.select('elevation').clip(clip);
var slope = ee.Terrain.slope(elevation).clip(clip);
var aspect = ee.Terrain.aspect(elevation).clip(clip);
var imageVisParams = {bands: ['elevation'], min: 1, max: 3445,  gamma: [1.85], opacity: 1};
Map.addLayer(elevation, imageVisParams, 'Elevation', false);
Map.addLayer(slope, {}, 'slope', false);
Map.addLayer(aspect, {}, 'aspect', false);

var img = ee.Image.cat([image2, image3]);
// print('img', img);
var img = ee.Image(img).divide(255);
var bandNames = img.bandNames();
print('img band names', bandNames); // ee.List of band names
Map.addLayer(img, {bands: ["ds10111040df", "ds10111040df", "ds10111040da"], gamma: 0.8}, 'DS1011-1040');
Map.centerObject(img.geometry(), 7);

/////////////Segmentation
var seeds = ee.Algorithms.Image.Segmentation.seedGrid(40);
// Run SNIC on the regular square grid.
var snic = ee.Algorithms.Image.Segmentation.SNIC({
  image: img, 
  size: 32,
  compactness: 0.1,
  connectivity: 4,
  neighborhoodSize:256,
  seeds: seeds
}).select(['ds10111040da_mean', 'ds10111040df_mean', 'clusters'], ['ds10111040da', 'ds10111040df', 'clusters']);//.reproject({crs: 'EPSG:4326', scale: 18});
// var snicbandNames = snic.bandNames();
// print('Snic band names: ', snicbandNames); // ee.List of band names

var clusters = snic.select('clusters').reproject({crs: 'EPSG:4326', scale: 18});
//Map.addLayer(clusters.randomVisualizer(), {}, 'clusters', false)
Map.addLayer(snic, {bands: ['ds10111040da', 'ds10111040df'/*, 'b1_2', 'b1_3'*/], min:0, max:1, gamma: 0.8}, 'means', false);
// Compute per-cluster stdDev.
var stdDev = img.addBands(clusters).reduceConnectedComponents(ee.Reducer.stdDev(), 'clusters', 1024).select(['ds10111040da', 'ds10111040df'], ['ds10111040da_StdDev', 'ds10111040df_StdDev']).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(stdDev, {min:0, max:0.1}, 'StdDev', false);
// Area, Perimeter, Width and Height
var area = ee.Image.pixelArea().addBands(clusters).reduceConnectedComponents(ee.Reducer.sum(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(area, {min:50000, max: 500000}, 'Cluster Area', false);

var minMax = clusters.reduceNeighborhood(ee.Reducer.minMax(), ee.Kernel.square(1)).reproject({crs: 'EPSG:4326', scale: 18}).reproject({crs: 'EPSG:4326', scale: 18});
var perimeterPixels = minMax.select(0).neq(minMax.select(1)).rename('perimeter').reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(perimeterPixels, {min: 0, max: 1, opacity: 0.5, palette: ['000000', 'ffffff']}, 'perimeterPixels', false);

var perimeter = perimeterPixels.addBands(clusters)
    .reduceConnectedComponents(ee.Reducer.sum(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(perimeter, {min: 100, max: 400}, 'Perimeter size', false);

var sizes = ee.Image.pixelLonLat().addBands(clusters).reduceConnectedComponents(ee.Reducer.minMax(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
var width = sizes.select('longitude_max').subtract(sizes.select('longitude_min')).rename('width').reproject({crs: 'EPSG:4326', scale: 18});
var height = sizes.select('latitude_max').subtract(sizes.select('latitude_min')).rename('height').reproject({crs: 'EPSG:4326', scale: 18}).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(width, {min:0, max:0.02}, 'Cluster width', false);
Map.addLayer(height, {min:0, max:0.02}, 'Cluster height', false);
var shape = area.sqrt().divide(perimeter).select(['area'], ['shape']).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(shape, {}, 'shape', false);
var entropyDA = entropy_DA.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(entropyDA, null, 'entropyDA', false);
var entropyDF = entropy_DF.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(entropyDF, null, 'entropyDF', false);
var homogeneityDA = homogeneity_DA.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(homogeneityDA, null, 'homogeneityDA', false);
var homogeneityDF = homogeneity_DF.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(homogeneityDF, null, 'homogeneityDF', false);
var angularSecondMomentDA = angularSecondMoment_DA.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(angularSecondMomentDA, null, 'angularSecondMomentDA', false);
var angularSecondMomentDF = angularSecondMoment_DF.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(angularSecondMomentDF, null, 'angularSecondMomentDF', false);
var elevation_10111040 = elevation.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(elevation_10111040, {}, 'elevation_10111040', false);
var slope_10111040 = slope.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(slope_10111040, {}, 'slope_10111040', false);
var aspect_10111040 = aspect.addBands(clusters).reduceConnectedComponents(ee.Reducer.mean(), 'clusters', 1024).reproject({crs: 'EPSG:4326', scale: 18});
Map.addLayer(aspect_10111040, {}, 'aspect_10111040', false);

//Classification
var objectPropertiesImage = ee.Image.cat([
  snic.select(['ds10111040da', 'ds10111040df']),
  stdDev,
  area,
  perimeter,
  width,
  height,
  shape,
  entropyDA,
  entropyDF,
  homogeneityDA,
  homogeneityDF,
  angularSecondMomentDA,
  angularSecondMomentDF,
  elevation_10111040,
  slope_10111040,
  aspect_10111040
  ]).float();
// print (objectPropertiesImage);
var bandNames = objectPropertiesImage.bandNames();
print('objectPropertiesImage bandNames', bandNames);
var bandss = ['ds10111040da', 'ds10111040df', 'ds10111040da_StdDev', 'ds10111040df_StdDev', 'area', 'width', 'height', 'shape', 'ds10111040da_ent', 'ds10111040df_ent', 'ds10111040da_idm', 'ds10111040df_idm', 'ds10111040da_asm', 'ds10111040df_asm', 'slope', 'aspect', 'elevation'];

var assetIdTR='users/rizayeva/Training10111040';
var assetIdTE='users/rizayeva/Testing10111040';

// //Make a list that contains all the imagery in the asset directory
var assetListTR = ee.List(ee.data.getList({'id':assetIdTR}));
var assetListTE = ee.List(ee.data.getList({'id':assetIdTE}));
print('Training data', assetListTR);
print('Testing data', assetListTE);
var n=assetListTR.size().getInfo();

//Generate a feature  collection that contains 5 sets of testing data
// var listofcollection = function(assetListTR/*, assetListTE*/, size){
  var classification = ee.ImageCollection([]);
  var overallAccuracy = ee.List([]); //ee.FeatureCollection([]);
  for (var i=0; i<n; i++){
    var valueTR=ee.Dictionary(assetListTR.get(i));
    var imgIDTR=ee.String(valueTR.get('id')).getInfo();
    var train=ee.FeatureCollection(imgIDTR);
    // print('train', train);
    // trainingTR=training.merge(imgs)

// Overlay the points on the imagery to get training.
var training = objectPropertiesImage.sampleRegions({
  collection: train,
  properties: ['Classes'],
  scale: 2.5
});

/////////////////////RF classification
// Train a CART classifier with default parameters
var classifier = ee.Classifier.smileRandomForest(100).train(training, 'Classes', bandss);

// Classify the image with the same bands used for training.
var classified = objectPropertiesImage.classify(classifier);
// var classified = classified.addBands(clusters).reduceConnectedComponents(ee.Reducer.mode(), 'clusters', 1024);//.reproject({crs: 'EPSG:4326', scale: 18});
// print('classified', classified); 
Map.addLayer(classified, {min: 1, max: 11, palette: palette}, 'Classified', false);

// // Export the Image - uncomment if want to export each
// Export.image.toAsset({
//   image: classified.toByte(),//.toFloat(),
//   description: "classification_objectRF_wDEM" + (i+1),
//   assetId: "classification_objectRF_wDEM" + (i+1),
//   scale: 2.5,
//   region: clip,//train.geometry().bounds(),
//   maxPixels:1e13,
// });

// // // ///////////Overall map
classification=classification.merge(classified);

//////////////////////Validation
  var valueTE=ee.Dictionary(assetListTE.get(i));
  var imgIDTE=ee.String(valueTE.get('id')).getInfo();
  var test=ee.FeatureCollection(imgIDTE);
  // print('test', test);
  // testing=testing.merge(imgs)

var validation = objectPropertiesImage.sampleRegions({
  collection: test,
  properties: ['Classes'],
  scale: 2.5
});
var validated = validation.classify(classifier);

// Get a confusion matrix representing expected accuracy.
var testAccuracy = validated.errorMatrix('Classes', 'classification');
// print('Validation error matrix_wDEM' + (i+1), testAccuracy);
// print('Validation overall accuracy_wDEM' + (i+1), testAccuracy.accuracy());
var Matrix = ee.Feature(null, {matrix: testAccuracy.array()});
// print(Matrix);
var overall = testAccuracy.accuracy();
// var accuracyMatrix = ee.Feature(null, {matrix: overall.array()});
// print(accuracyMatrix);

// // Export the Accuracy - uncomment if want to export each
// Export.table.toDrive({
//   collection: ee.FeatureCollection(Matrix),
//   description:'testAccuracy_object08122021_wDEM' + (i+1),
//   folder: 'testAccuracy',
//   fileFormat: 'csv'
// });

overallAccuracy = overallAccuracy.add(overall);

  }
var classifiedX = classification
print(classifiedX)

var bestClassificationObj = classifiedX.mode();
// Map.addLayer(bestClassificationObj);
Map.addLayer(bestClassificationObj.toByte(), {min: 1, max: 11, palette: palette}, "Best_obj", false);
Export.image.toDrive({
  image: bestClassificationObj.toByte(),
  description: "bestClassificationObj_wDEM",
  folder: "objectBasedClassifications",
  scale: 2.5,
  region: clip,
  maxPixels:1e13,
});

var overallAccuracyObj = overallAccuracy.reduce(ee.Reducer.mean());
print('Overall accuracy', overallAccuracyObj);
var standardDeviation = overallAccuracy.reduce(ee.Reducer.stdDev());
print('SD', standardDeviation);

Export.table.toDrive({
  collection: overallAccuracyObj,
  description:'overallAccuracy10111040',
  folder: 'classification_accuracies',
  fileFormat: 'csv'
});

Export.table.toDrive({
  collection: standardDeviation,
  description:'standardDeviation10111040',
  folder: 'classification_accuracies',
  fileFormat: 'csv'
});
